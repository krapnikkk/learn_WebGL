# OpenGL ES着色器语言（GLSL ES）

## 着色器代码

顶点着色器示例
```
//顶点着色器
attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_MvpMatrix;
varying vec4 v_Color;
void main() {
    gl_Position = u_MvpMatrix * a_Position;
    v_Color = a_Color;
}

```

片元着色器示例
```
//片元着色器
#ifdef GLSL_ES
precision mediump float;
#endif
varying vec4 v_Color;
void main() {
    gl_FragColor = v_Color;
}
```

## GLSL ES概述

GLSL ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化一部分功能后形成的。GLSL ES的目标平台是消费电子产品或嵌入式设备，如智能手机或游戏主机等，因此简化GLSL ES能够允许硬件厂商对这些设备的硬件进行简化，由此带来的好处是降低了硬件的功耗，以及更重要的，减少了性能开销。

[WebGL](https://www.khronos.org/registry/webgl/specs/latest/1.0/)并不支持GLSL ES1.00的所有特性；实际上，它支持的是1.00版本的一个子集，其中只包括WebGL需要的那些核心特性。

## GLSL ES基础

### 基础

- 程序是大小写敏感。
- 每一个语句都应该以一个英文分号(;)结束。

### 执行次序

着色器程序和C语言接近，它从main()函数开始执行的。着色器程序必须有且仅有一个main()函数，而且该函数不能接受任何参数。

main函数前的void关键字表示这个函数不返回任何值。

### 注释

- 单行注释：//后直到换行处的所有字符为注释
```
int kp = 496;//kp是一个卡布列克数
```
- 双行注释：/*和*/之间的所有字符串为注释
```
/*我今天休息一天
  我明天想休息一天
*/
```

## 数据值和类型（数值和布尔值）

GLSL支持两种数值类型：
- 数值类型：GLSL ES支持整型数（比如0、1、2）和浮点数（比如3.14、29.98、0.23571）。没有小数点（.）的值被认为是整数型，而有小数点的值则被认为是浮点数。
- 布尔值类型：GLSL ES支持布尔值类型，包括true和false两个布尔常量。

## 变量
- 只包括a-z，A-Z，0-9和下划线（_）
- 变量名的首字母不能是数字
- 不能以gl_、webgl_或者_webgl_开头，这些前缀已经被OpenGL ES保留了
- 不能是GLSL ES的关键字和保留字（下表），变量名的一部分可以是它们。
  
### GLSL ES关键字
|           |           |             |        |       |           |
| --------- | --------- | ----------- | ------ | ----- | --------- |
| attribute | bool      | break       | bvec2  | bvec3 | bvec4     |
| const     | continue  | discard     | do     | else  | false     |
| float     | for       | highp       | if     | in    | inout     |
| Int       | invariant | ivec2       | ivec3  | ivec4 | lowp      |
| mat2      | mat3      | mat4        | medium | out   | precision |
| return    | sampler2D | samplerCube | struct | true  | uniform   |
| varying   | vec2      | vec3        | vec4   | void  | while     |

### GLSL ES保留字
|           |               |           |                 |               |                     |                |
| --------- | ------------- | --------- | --------------- | ------------- | ------------------- | -------------- |
| asm       | cast          | class     | default         | double        | dvec2               | dvec3          |
| dvec4     | enum          | extern    | external        | fixed         | flat                | fvec2          |
| fvec3     | fvec4         | goto      | half            | hvec2         | hvec3               | hvec4          |
| inline    | input         | interface | long            | namespace     | noinline            | output         |
| packed    | public        | sampler1D | sampler1DShadow | sampler2DRect | sampler2DRectShadow | shadow2DShadow |
| sampler3D | sampler3DRect | short     | sizeof          | static        | superp              | switch         |
| template  | this          | typedef   | union           | unsigned      | using               | volatile       |

## GLSL ES是强类型语言
GLSL ES要求具体地指明变量的数据类型。
    <类型><变量名>
  
## 基本类型
| 类型  | 描述                                                |
| ----- | --------------------------------------------------- |
| float | 单精度浮点数类型。该类型的变量表示一个单精度浮点数  |
| int   | 整数型。该类型的变量表示一个整数                    |
| bool  | 布尔值。该类型的变量表示一个布尔值（true或者false） |

### 赋值和类型变换

使用等号（=）可以将赋值给变量。GLSL ES是强类型语言，所以如果等号左侧变量的类型与等号右侧的值（或变量）类型不一致，就会出错。
```
init i = 8;
float f1 = 8;//错误
float f2 = 8.0;
float f3 = 8.0f;//错误
```
要将一个整数数值赋值给浮点型变量，需要将整型数转换成浮点数，这个过程称为类型转换。
```
int i = 8;
float f1 = float(i);
float f2 = float(8);
```
GLSL ES支持以下几种用于类型转换的内置函数。
| 转换         | 函数        | 描述                                    |
| ------------ | ----------- | --------------------------------------- |
| 转换为整数型 | int(float)  | 将浮点数的小数部分删去，转换为整型数    |
|              | int(bool)   | true被转换为1，false被转换为0           |
| 转换为浮点数 | float(int)  | 将整数型转换为浮点数                    |
|              | float(bool) | true被转换为1.0，false被转换为0.0       |
| 转换为布尔值 | bool(int)   | 0被转换为false，其他非0值被转换为true   |
|              | bool(float) | 0.0被转换为false，其他非0值被转换为true |

### 运算符
| 类型                             | GLSL ES数据类型          | 描述                                                                          |
| -------------------------------- | ------------------------ | ----------------------------------------------------------------------------- |
| -                                | 取负（比如指定一个负数） | int或float                                                                    |
| *                                | 乘法                     | int或者float,运算的返回值类型与参与运算的值类型相同                           |
| /                                | 除法                     |                                                                               |
| +                                | 加法                     |                                                                               |
| -                                | 减法                     |                                                                               |
| ++                               | 自增（前缀后后缀）       | int或者float,运算的返回值类型与参与运算的值类型相同                           |
| --                               | 自减（前缀后后缀）       |                                                                               |
| =                                | 赋值                     | int、float或bool                                                              |
| += -= *= /=                      | 算术赋值                 | int或float                                                                    |
| < > <= >=                        | 比较                     |                                                                               |
| == !=                            | 比较（是否相等）         | int、float或bool                                                              |
| !                                | 取反                     | bool或结果为bool类型的表达式                                                  |
| &&                               | 逻辑与                   |                                                                               |
| \|\|                             | 逻辑或                   |                                                                               |
| ^^                               | 逻辑异或                 |                                                                               |
| condition?expression:expression2 | 三元选择                 | condition的类型为bool，expression1和expression2的类型可以是除数组外的任意类型 |

## 矢量和矩阵
GLSL ES支持矢量和矩阵类型，矢量和矩阵类型的变量都包含多个元素，每个元素都是一个数值（int,float或bool）。矢量将这些元素排列成一列，可以用来表示顶点坐标或者颜色值等，而矩阵则将元素划分成列和行，可以用来表示变换矩阵。

矢量：(1,2,3)

矩阵：
$$
\left[
 \begin{matrix}
   1 & 4 & 7 \\
   2 & 5 & 8 \\
   3 & 6 & 9 
  \end{matrix} 
\right]
$$

### 矢量和矩阵类型
| 类型 | GLSL_ES数据类型     | 描述                                                    |
| ---- | ------------------- | ------------------------------------------------------- |
| 矢量 | vec2、vec3、vec4    | 具有2、3、4个浮点数元素的矢量                           |
|      | ivec2、ivec3、ivec4 | 具有2、3、4个整型数元素的矢量                           |
|      | bvec2、bvec3、bvec4 | 具有2、3、4个布尔值元素的矢量                           |
| 矩阵 | mat2、mat3、mat4    | 具有2、3、4个浮点数元素的矩阵（分别具有4，9，16个元素） |

### 赋值和构造
我们使用等号（=）来对于矢量和矩阵进行赋值操作。赋值运算符左右两边的变量/值的类型必须一致，左右两边的（矢量或者矩阵）元素个数必须相同。使用构造函数创建指定类型的变量，构造函数的名称和其创建的变量的类型名称总是一致的。

### 矢量构造函数
使用构造函数创建矢量时，只向构造函数传入一个参数时，构造函数就会自动地将这个参数复制给新建矢量的所有元素。但是如果构造函数接受了不止1个参数，但是参数的个数又比矢量的元素个数少，那么就会出错。
```
vec3 v3 = vec3(1.0, 0.0, 0.5); //将v3设为(1.0,0.0,0.5)
vec2 v2 = vec2(v3);            //使用v3的前两个元素，将v2设为(1.0,0.0)
vec4 v4 = vec4(1.0);           //将v4设置为(1.0,1.0,1.0,1.0)
```

将多个矢量组合成一个矢量，先把第一个参数的矢量的所有元素填充进来，如果还没有填满，就继续使用第二个参数的矢量的元素填充。
```
vec4 v4b = vec(v2,v4);         //将v4设为(1.0,0.0,1.0,1.0)
```

### 矩阵构造函数
储存在矩阵中的元素是按照列主序排列的。
- 向矩阵构造函数中传入矩阵的每一个元素的数值来构造矩阵，传入值的顺序必须是列主序的。
  ```
  mat4 m4 = mat4( 1.0, 2.0, 3.0, 4.0,
                  5.0, 6.0, 7.0, 8.0,
                  9.0,10.0,11.0,12.0,
                  13.0,14.0,15.0,16.0);
  ```
$$
\left[
    \begin{matrix}
    1.0 & 5.0 & 9.0 & 13.0 \\
    2.0 & 6.0 & 10.0 & 14.0 \\
    3.0 & 7.0 & 11.0 & 15.0 \\
    4.0 & 8.0 & 12.0 & 16.0 
    \end{matrix}
\right]
$$

-向矩阵构造函数中传入一个或多个矢量，按照列主序使用矢量里的元素来构造矩阵。
```
vec2 v2_1 = vec2(1.0,3.0);
vec2 v2_2 = vec2(2.0,4.0);
mat2 m2_1 = mat2(v2_1,v2_2);

vec4 v4 = vec4(1.0,3.0,2.0,4.0);
mat2 m2_2 = mat2(v4);
```

-向矩阵构造函数中传入矢量和数值，按照列主序使用矢量里面的元素值直接传入的数值来构造矩阵。
```
//使用两个浮点数和一个vec2对象来创建mat2对象
mat2 m2 = mat2(1.0,3.0,v2_2);
```
-向构造函数中传入单个数值，这样将生成一个对角线上元素都是该数值，其他元素为0.0的矩阵。
```
mat4 m4 = mat4(1.0);//1.0 0.0 0.0 0.0
                    //0.0 1.0 0.0 0.0
                    //0.0 0.0 1.0 0.0
                    //0.0 0.0 0.0 1.0
```
- 与矢量构造函数类似，如果传入的数值的数量大于1，又没有达到矩阵元素的数量，就会出错。

### 访问元素
为了访问矢量或者矩阵中的元素，可以使用.或者[]运算符。

### 运算符
在矢量变量名后接点运算符（.），然后接上分量名，就可以访问矢量的元素了。

| ---- | ---- |
| 类别 | 描述 |
| x、y、z、w | 用来获取顶点坐标分量 |
| r、g、b、a | 用来获取颜色分量 |
| s、t、p、q | 用来获取纹理坐标分量 |
由于矢量可以用来存储顶点的坐标、颜色和纹理坐标，所以GLSL ES支持以上三种分量名称以增强程序的可读性。事实上，任何矢量的x、r或s分量都会返回第1个分量。y、g、t分量都会返回第2个分量。
```
vec3 v3 = vec3(1.0,2.0,3.0);
float f;
f = v3.x;//1.0
f = v3.y;//2.0
f = v3.z;//3.0

f = v3.r;//1.0
f = v3.s;//1.0
```

如果试图访问超过矢量长度的分量，就会出错。
```
f = v3.w;
```
将（同一个集合的）多个分量名共同置于点运算符后，就可以从矢量中同时抽取出多个分量。这个过程称作混合。
```
vec2 v2;
v2 = v3.xy;//(1.0,2.0);
v2 = v3.yz;//(2.0,3.0);
v2 = v3.xz;//(1.0,3.0); 可以跳过任意分量
v2 = v3.yx;//(1.0,2.0); 可以逆序
v2 = v3.xx;//(1.0,1.0); 可以重复任意分量
```
聚合分量名也可以用来作为赋值表达式（=）的左值【多个分量名必须属于同一个集合】：
```
vec4 position = vec4(1.0,2.0,3.0,4.0);
position.xw = vec2(5.0,6.0);//position = (5.0,2.0,3.0,6.0);
```

### []运算符
除了.运算符，还可以使用[]运算符并通过数组下标来访问矢量或矩阵的元素。
```
mat4 m4 = mat4(1.0, 2.0, 3.0,4.0,
                5.0, 6.0, 7.0, 8.0,
                9.0, 10.0, 11.0, 12.0
                13.0, 14.0, 15.0, 16.0);
vec4 v4 = m4[0]; //[1.0,2.0,3.0,4.0]
```
连续使用两个[]运算符可以访问某列的某个元素：
```
float m23 = m4[1][2];//(7.0);
```

使用[]运算符和分量名来访问矩阵中的元素：
```
float m32 = m4[2].y;//(10.0);
```
在[]运算符中只能出现索引值必须是常量索引值，常量索引值定义如下：
- 整型字面量
- 用const修饰的全局变量或局部变量，不包括函数参数
- 循环索引
- 由前述三条中的项组成的表达式
```
const int index = 0;
vec4 v4a = m4[index];
vec4 v4b = m4[index + 1];

int index2 = 0;
vec4 v4c = m4[index2];//错误
```
### 运算符
矢量和矩阵可用的运算符
| 运算符         | 运算             | 适用数据类型                             |
| -------------- | ---------------- | ---------------------------------------- |
| *              | 乘法             | 适用于vec[234]和mat[234]                 |
| /              | 除法             | 适用于vec[234]和mat[234]                 |
| +              | 加法             | 运算结果的数据类型与参与运算的类型相一致 |
| -              | 减法             |                                          |
| ++             | 自增(前缀或后缀) | 适用于vec[234]和mat[234]                 |
| --             | 自减(前缀或后缀) |                                          |
| =              | 赋值             | 适用于vec[234]和mat[234]                 |
| +=、-=、*=、/= | 运算赋值         | 适用于vec[234]和mat[234]                 |
| ==、!=         | 比较             | 适用于vec[234]和mat[234]                 |
当运算赋值操作作用于矢量或矩阵时，实际上时逐分量地对矩阵或矢量的每一个元素进行独立的运算赋值。

### 矢量和浮点数的运算
```
vec3 v3a,v3b,v3c;
mat3 m3a,m3b,m3c;
float f;

v3b = v3a + f;//v3b.x = v3a.x + f;v3b.y = v3a.y + f;v3b.z = v3a.z + f;
```

### 矢量运算
矢量的运算操作发生在矢量的每个分量上。
```
v3c = v3a + v3b;//v3a.x + v3b.x;v3a.y+v3b.y;v3a.c+v3b.c;
```

### 矩阵和浮点数的运算
矩阵与浮点数的运算发生在矩阵的每个分量上。
```
m3b = m3a * f;//m3b[0].x = m3a[0].x * f;m3b[0].y = m3a[0].z * f;
              //m3b[1].x = m3a[1].x * f;m3b[1].y = m3a[1].z * f;
              //m3b[2].x = m3a[2].x * f;m3b[2].y = m3a[2].z * f;
```
### 矩阵右乘矢量
矩阵右乘矢量的结果是矢量，其中每个分量都是原矢量中的对应分量，乘上矩阵对应行的每个元素的积的加和。
```
v3b = m3a * v3a;
//v3b.x = m3a[0].x * v3a.x + m3a[1].x * v3a.y + m3a[2].x * v3a.z;
//v3b.y = m3a[0].y * v3a.x + m3a[1].y * v3a.y + m3a[2].y * v3a.z;
//v3b.z = m3a[0].z * v3a.x + m3a[1].z * v3a.y + m3a[2].z * v3a.z;
```

### 矩阵左乘矢量
```
v3b = v3a * m3a;
//v3b.x = v3a.x *m3a[0].x + v3b.y * m3a[0].y + v3a.z * m3a[0].z;
//v3b.y = v3a.x *m3a[1].x + v3b.y * m3a[1].y + v3b.z * m3a[1].z;
//v3c.z = v3a.x *m3a[2].x + v3b.z * m3a[2].y + v3b.z * m3a[2].z;
```

### 矩阵与矩阵相乘
```
m3c = m3a * m3b;
//m3c[0].x = m3a[0].x * m3b[0].x + m3a[1].x * m3b[0].y + m3a[2].x * m3b[0].z;
//m3c[1].x = m3a[0].x * m3b[1].x + m3a[1].x * m3b[1].y + m3a[2].x * m3b[1].z;
//m3c[2].x = m3a[0].x * m3b[2].x + m3a[1].x * m3b[2].y + m3a[2].x * m3b[2].z;
//m3c[0].y = m3a[0].y * m3b[0].x + m3a[1].y * m3b[0].y + m3a[2].y * m3b[0].z;
//m3c[1].y = m3a[0].y * m3b[1].x + m3a[1].y * m3b[1].y + m3a[2].y * m3b[1].z;
//m3c[2].y = m3a[0].y * m3b[2].x + m3a[1].y * m3b[2].y + m3a[2].y * m3b[2].z;
//m3c[0].z = m3a[0].z * m3b[0].x + m3a[1].z * m3b[0].y + m3a[2].z * m3b[0].z;
//m3c[1].z = m3a[0].z * m3b[1].x + m3a[1].z * m3b[1].y + m3a[2].z * m3b[1].z;
//m3c[2].z = m3a[0].z * m3b[2].x + m3a[1].z * m3b[2].y + m3a[2].z * m3b[2].z;
```

## 结构体
GLSL ES支持用户自定义的类型，即结构体。使用关键词struct，将已存在的类型聚合到一起，就可以定义为结构体。
```
struct light{//定义结构体类型light
    vec4 color;
    vec3 position;
}

light l1,l2;//声明ligth类型的l1和l2
```
为了方便，可以在同一条语句中定义结构体并声明该结构体类型的变量。
```
struct light{
    vec4 color;
    vec3 position;
}l1;
```

### 赋值和构造
结构体有标准的构造函数，其名称和结构体名一致。构造函数的参数顺序必须与结构体定义中的成员顺序一致。
```
l1 = light(vec4(0.0,1.0,0.0,1.0),vec3(8.0,3.0,0.0));
```

### 访问成员
在结构体变量名后跟点运算符（.），然后再加上成员名，就可以访问变量的成员。
```
vec4 color = l1.color;
vec3 position = l1.position;
```

### 运算符 
结构体的成员可以参与其自身类型支持的任何运算，但结构体本身只支持两种运算：赋值（=）和比较（==和!=）。
| 运算符 | 运算 | 描述 |
| ----- | ----- | ----- |
| = | 赋值 | 赋值和比较运算符不适用于含有数组与纹理成员的结构体 |
| ==、!= | 比较 |  |

## 数组
GLSL ES支持数组类型。GLSL ES只支持一维数组。声明数组只需要在变量名后加上中括号（[]）和数组的长度。
```
float floatArray[4];
vec4 vec4Array[2];
```
数组的长度必须大于0的整数常量表达式：
- 整型字面量
- 用const限定字修饰的全局变量或局部变量，不包括函数参数。
- 用前述两条中的项组成的表达式

数组不能再声明时被一次性地初始化，必须显示地对每个元素进行初始化。

## 取样器（纹理）
将GLSL ES支持的一种内置类型称为取样器（sampler），我们必须通过该类型变量访问纹理。

有两种基本的取样器类型：sampler2D和samplerCube。取样器变量只能是uniform变量，或者需要访问纹理的函数，如texture2D()函数的参数。
```
uniform sampler2D u_Sampler;
```
唯一能赋值给取样器变量的就是纹理单元编号，而且只能使用WebGL方法gl.uniform1i()进行赋值。

取样器类型变量受到着色器支持的纹理单元的最大数量限制。

| 着色器 | 表示最大数量的内置常量 | 最小数量 |
| ----- | ----- | ----- |
| 顶点着色器 | const mediump int gl_MaxVertexTextureImageUnits | 0 |
| 片元着色器 | const mediump int gl_MaxTextureUnits | 8 |

## 运算符优先级
| 优先级 | 运算符 |
| ----- | ----- |
| 1 | 圆括号（()） |
| 2 | 函数调用（()），数组索引（[]）,点操作符（.） |
| 3 | 自增和自减（++、--），负（-），取反（!） |
| 4 | 乘（*），除（/），余（%） |
| 5 | 加（+），减（-） |
| 6 | 按位移（<<、>>） |
| 7 | 大小比较（<、<=、>、>=） |
| 8 | 判断相等（==、!=） |
| 9 | 按位与（&） |
| 10 | 按位异或（^） |
| 11 | 按位或（|） |
| 12 | 与（&&） |
| 13 | 异或（^^） |
| 14 | 或（||） |
| 15 | 三元判断（?:） |
| 16 | 运算赋值（+=、-=、*=、/=、&=、<<=、>>=、&=、^=、!=） |
| 17 | 顺序运算符（,） |

## 程序流程控制：分支和循环

### if语句和if-else语句
if语句或if-else语句中都必须包含一个布尔值，或者是产生布尔值的表达式。

### for语句
循环变量只能在初始化表达式中定义，条件表达式可以为空，空的表达式返回true。
- 只允许有一个循环变量，循环变量只能是int或者float类型。
- 循环表达式必须是以下形式
-- i++，i--,i+=或者i-=常量表达式
- 条件表达式必须是循环变量与整形变量的比较
- 在循环体内，循环变量不可被赋值。
【这些限制的存在是为了是编译器就能够对for循环进行内联展开。】

### continue、break和discard语句
- continue:中止包含该语句的最内层循环和执行循环表达式（递增/递减循环变量），然后执行下一次循环。
- break:中止包含该语句的最内层循环，并不再继续执行循环。
- discard:只能用在片元着色器中使用，表示放弃当前片元直接处理下一个片元。


## 函数
函数没有参数也是允许的。如果函数不返回值，那么函数中就不需要有return语句，返回的类型必须是void。也可以将自己定义的结构体类型指定为返回类型，但是结构体的成员中不能有数组。

不能再一个函数内部调用它本身。

函数格式：
```
返回类型 函数名(type0 arg0,type1 arg1,...,typen argn){
  函数计算
  return 返回值;
}
```

```
//将RGBA颜色值转换为亮度值
float luma(vec4 color){
  float r = color.r;
  float g = color.g;
  float b = color.b;
  return 0.2126 * r + 0.7162 * g + 0.0722 * b;
}
```

### 范式声明
如果函数定义在其调用之后，那么我们必须在进行调用表之前先声明该函数的规范。
```
float luma(vec4);//规范声明
main(){
  ···
  float brightness = luma(color);//luma()在定义之前就被调用了
  ···
}

float luma(vec4 color){
  return 0.2126 * color.r + 0.7162 * color.g + 0.0722 * color.b;
}
```

### 参数限定词
  在GLSL ES中，可以为函数参数指定限定字，以控制参数的行为。
  函数参数定义成：
  - 传递给函数的
  - 将要在函数中被赋值的
  - 即传递给函数的，又是将要在函数中被赋值的

| 类型 | 规则 | 描述 |
| ---- | ---- | ---- |
| in | 向函数中传入值 | 参数传入函数，函数内可以使用参数的值，也可以修改其值。但函数内部的修改不会影响传入的变量 |
| const in | 向函数中传入值 | 参数传入函数，函数内可以使用参数的值，但不能修改 | 
| out | 在函数中被赋值，并被传出 | 传入变量的引用，若其在函数内被修改，会影响到函数外部传入的变量 |
| inout | 传入函数，同时在函数中被赋值，并被传出 | 传入变量的引用，函数会用到变量的初始值，然后修改变量的值。会影响到函数外部传入的变量 |
| <无：默认> | 将一个值传给函数 | 和in一样 |

```
void luma2(in vec3 color,out float brightness){
  brightness = 0.2126 * color.r + 0.7162 * color.g + 0.0722 * color.b;
}

luma2(color,brightness);//函数存储在brightness中
```

## 内置函数
| 类别 | 内置函数 |
| ---- | ---- |
| 角度函数 | radians(角度制转弧度制)，degrees(弧度制转角度值) |
| 三角函数 | sin(正弦)，cos(余弦)，tan(正切)，asin(反正弦)，acos(反余弦)，atan(反正切) |
| 指数函数 | pow(x^y)，exp(自然指数)，log(自然对数)，exps(2^x)，log2(以2为底对数)，sqrt(开平方)，inversesqrt(开平方的倒数) |
| 通用函数 | abs(绝对值) min(最小值) max(最大值) mod(取余数) sign(取正负号) floor(向下取整) ceil(向上取整) clamp(限定范围) mix(线性内插) step(步进函数) smoothstep(艾米内插步进) fract(获取小数部分) |
| 几何函数 | length(矢量长度) distance(两点间的距离) dot(内积) cross(外积) normalize(归一化)
 reflect(矢量反射) faceforward(使向量“朝前”) |
| 矩阵函数 | matrixCmpMult(逐元素乘法) |
| 矢量函数 | lessThan(逐元素小于) lessThanEqual(逐元素小于等于) greaterThan(逐元素大于) greaterThanEqual(逐元素大于等于) equal(逐元素相等) notEqual(逐元素不等) any(任一元素为true则为true) all(所有元素为true则为true) not(逐元素取补) |
| 纹理查询函数 | texture2D(在而二维纹理中获取纹素) textureCube(在立方体纹理中获取纹素) text2DProj(texture2D的投影版本) texture2DLod(texture2D的金字塔版本) textureCubeLod(textureCube的金字塔版本) texture2DProjLod(textureCube的投影版本) |

## 全局变量和局部变量
在GLSL ES中，如果变量声明在函数的外面，那么它就是全局变量，如果声明在函数内部，那就是局部变量。

## 存储限定字
存储限定字是用来限制和修饰变量的。
### const变量
const限定字表示该变量的值不能被改变。声明的同时必须对变量进行初始化，声明之后就不能再去改变它们的值了。

### Attribute变量
attribute变量只能出现在顶点着色器中，只能被声明为全局变量，被用来表示逐顶点的信息。
顶点着色器中能够容纳的attitude变量的最大数目与设备有关，可以通过内置的全局常量来获取最大数目。
不管设备配置如何，支持WebGL的环境都支持至少8个attribute变量。

### uniform变量
uniform变量可以用在顶点着色器和片元着色器中，且必须是全局变量。
uniform变量是只读的，它可以是除了数组或结构体之外的任意类型。
如果顶点着色器和片元着色器中声明了同名的uniform变量，那么它就会被两种着色器共享。

### varying变量
varying变量必须是全局变量，它的任务是从顶点着色器向片元着色器传输数据。必须在两种着色器中声明同名、同类型的varying变量。
varying变量只能是以下类型：flaot、vec2、vec3、vec4、mat2、mat3和mat4。
顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光栅化的过程：根据绘制的图形，对前者（顶点着色器varying变量）进行内插，然后再传递给后者（片元着色器varying变量）。正因为varying变量需要被内插，所以我们需要限制它的数据类型。

attribute变量 uniform变量和varying变量的数目限制
| 变量类别 | 内置全局变量（表示最大数量） | 最小值 |
| ------ | ------ | ------ |
| attribute变量 | const mediump int gl_MaxVertexAttribs | 8 |
| uniform变量（顶点着色器）| const mediump int gl_MaxVertexUniformVectors | 128 |
| uniform变量（片元着色器） | const mediump int MaxFragmentUniformVectors | 16 |
| varying变量 | const mediump int gl_MaxVaryingVectors | 8 |

## 精度限定字
GLSL ES新引入了精度限定字，目的是帮助着色器程序提高运行效率，削减内存开支。
精度限定字用来表示每种数据具有的精度（比特数）。
高精度的程序需要更大的开销（包括更大的内存和更久的计算时间），而低精度的程序需要的开销则小得很多。
```
#ifdef GL_ES
precision mediump float;
#endif
```

| 精度限定字 | 描述 | 默认数值范围和精度 |
| ------ | ------ | ------ |
| highp | 高精度，顶点着色器的最低精度 | Float(-2^62,2^62)精度2^-16 int(-2^16,2^16) |
| mediump | 中精度，介于高精度与低精度之间，片元着色器的最低精度 | Float(-2^14,2^14)精度2^-10 int(-2^10,2^10) |
| lowp | 低精度，低于中精度，可以表示所有颜色 | Float(-2,2)精度2^-8 int(-2^8,2^8) |

使用关键字precision来声明着色器的默认精度，这行代码必须在顶点着色器或片元着色器的顶部，其格式如下：
precision 精度限定字 类型名称

数据类型的默认精度
| 着色器类型 | 数据类型 | 默认精度 |
| ---- | ---- | ---- |
| 顶点着色器 | int | highp |
|  | float | highp |
|  | sampler2D | lowp |
|  | samplerCube | lowp |
| 片元着色器 | int | highp |
|  | float | 无 |
|  | sampler2D | lowp |
|  | samplerCube | lowp |

  片元着色器中的float类型没有默认精度，我们需要手动指定。

## 预处理指令
  GLSL ES支持预处理指令。预处理指令用来在真正编译之前对代码进行预处理，都是以（#）开始
  ```
  #ifdef GL_ES //是否已经定于GL_ES宏
  precision mediump float;
  #endif
  ```

  三种预处理指令：
  ```
  #if 条件表达式
  如果条件表达式为真，执行到这里
  #endif

  #ifdef 某宏
  如果定义了某宏，执行这里
  #endif

  #ifndef 某宏
  如果没有定义某宏，执行这里
  #undef
  ```
  ```
  可以使用#define指令来进行定义宏定义。
  #define 宏名 红内容

  可以使用#undef指令来解除宏定义
  #undef 宏名

  可以使用#else 指令配置#ifdef
  #define NUM 100
  #if NUM == 100
  如果宏NUM为100，执行这里
  #else
  否则，执行这里
  #endif
  ```

  预定义的内置宏
  | 宏 | 描述 |
  | --- | --- |
  | GL_ES | 在OpenGL ES 2.0中定义为1 |
  | GL_FRAGMENT_PRECISION_HIGH | 片元着色器支持highp精度 |