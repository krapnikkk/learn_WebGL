# OpenGL ES着色器语言（GLSL ES）

## 节本着色器代码

顶点着色器示例
```
//顶点着色器
attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_MvpMatrix;
varying vec4 v_Color;
void main() {
    gl_Position = u_MvpMatrix * a_Position;
    v_Color = a_Color;
}

```

片元着色器示例
```
//片元着色器
#ifdef GLSL_ES
precision mediump float;
#endif
varying vec4 v_Color;
void main() {
    gl_FragColor = v_Color;
}
```

## GLSL ES概述

GLSL ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化一部分功能后形成的。GLSL ES的目标平台是消费电子产品或嵌入式设备，如智能手机或游戏主机等，因此简化GLSL ES能够允许硬件厂商对这些设备的硬件进行简化，由此带来的好处是降低了硬件的功耗，以及更重要的，减少了性能开销。

[WebGL](https://www.khronos.org/registry/webgl/specs/latest/1.0/)并不支持GLSL ES1.00的所有特性；实际上，它支持的是1.00版本的一个子集，其中只包括WebGL需要的那些核心特性。

## GLSL ES基础

### 基础

- 程序是大小写敏感。
- 每一个语句都应该以一个英文分号(;)结束。

### 执行次序

着色器程序和C语言接近，它从main()函数开始执行的。着色器程序必须有且仅有一个main()函数，而且该函数不能接受任何参数。

main函数前的void关键字表示这个函数不返回任何值。

### 注释

- 单行注释：//后直到换行处的所有字符为注释
```
int kp = 496;//kp是一个卡布列克数
```
- 双行注释：/*和*/之间的所有字符串为注释
```
/*我今天休息一天
  我明天想休息一天
*/
```

## 数据值和类型（数值和布尔值）

GLSL支持两种数值类型：
- 数值类型：GLSL ES支持整型数（比如0、1、2）和浮点数（比如3.14、29.98、0.23571）。没有小数点（.）的值被认为是整数型，而有小数点的值则被认为是浮点数。
- 布尔值类型：GLSL ES支持布尔值类型，包括true和false两个布尔常量。

## 变量
- 只包括a-z，A-Z，0-9和下划线（_）
- 变量名的首字母不能是数字
- 不能以gl_、webgl_或者_webgl_开头，这些前缀已经被OpenGL ES保留了
- 不能是GLSL ES的关键字和保留字（下表），变量名的一部分可以是它们。
  
### GLSL ES关键字
|           |           |             |        |       |           |
| --------- | --------- | ----------- | ------ | ----- | --------- |
| attribute | bool      | break       | bvec2  | bvec3 | bvec4     |
| const     | continue  | discard     | do     | else  | false     |
| float     | for       | highp       | if     | in    | inout     |
| Int       | invariant | ivec2       | ivec3  | ivec4 | lowp      |
| mat2      | mat3      | mat4        | medium | out   | precision |
| return    | sampler2D | samplerCube | struct | true  | uniform   |
| varying   | vec2      | vec3        | vec4   | void  | while     |

### GLSL ES保留字
|           |               |           |                 |               |                     |                |
| --------- | ------------- | --------- | --------------- | ------------- | ------------------- | -------------- |
| asm       | cast          | class     | default         | double        | dvec2               | dvec3          |
| dvec4     | enum          | extern    | external        | fixed         | flat                | fvec2          |
| fvec3     | fvec4         | goto      | half            | hvec2         | hvec3               | hvec4          |
| inline    | input         | interface | long            | namespace     | noinline            | output         |
| packed    | public        | sampler1D | sampler1DShadow | sampler2DRect | sampler2DRectShadow | shadow2DShadow |
| sampler3D | sampler3DRect | short     | sizeof          | static        | superp              | switch         |
| template  | this          | typedef   | union           | unsigned      | using               | volatile       |

## GLSL ES是强类型语言
GLSL ES要求具体地指明变量的数据类型。
    <类型><变量名>
  
## 基本类型
| 类型  | 描述                                                |
| ----- | --------------------------------------------------- |
| float | 单精度浮点数类型。该类型的变量表示一个单精度浮点数  |
| int   | 整数型。该类型的变量表示一个整数                    |
| bool  | 布尔值。该类型的变量表示一个布尔值（true或者false） |

### 赋值和类型变换

使用等号（=）可以将赋值给变量。GLSL ES是强类型语言，所以如果等号左侧变量的类型与等号右侧的值（或变量）类型不一致，就会出错。
```
init i = 8;
float f1 = 8;//错误
float f2 = 8.0;
float f3 = 8.0f;//错误
```
要将一个整数数值赋值给浮点型变量，需要将整型数转换成浮点数，这个过程称为类型转换。
```
int i = 8;
float f1 = float(i);
float f2 = float(8);
```
GLSL ES支持以下几种用于类型转换的内置函数。
| 转换         | 函数        | 描述                                    |
| ------------ | ----------- | --------------------------------------- |
| 转换为整数型 | int(float)  | 将浮点数的小数部分删去，转换为整型数    |
|              | int(bool)   | true被转换为1，false被转换为0           |
| 转换为浮点数 | float(int)  | 将整数型转换为浮点数                    |
|              | float(bool) | true被转换为1.0，false被转换为0.0       |
| 转换为布尔值 | bool(int)   | 0被转换为false，其他非0值被转换为true   |
|              | bool(float) | 0.0被转换为false，其他非0值被转换为true |

### 运算符
| 类型                             | GLSL ES数据类型          | 描述                                                                          |
| -------------------------------- | ------------------------ | ----------------------------------------------------------------------------- |
| -                                | 取负（比如指定一个负数） | int或float                                                                    |
| *                                | 乘法                     | int或者float,运算的返回值类型与参与运算的值类型相同                           |
| /                                | 除法                     |                                                                               |
| +                                | 加法                     |                                                                               |
| -                                | 减法                     |                                                                               |
| ++                               | 自增（前缀后后缀）       | int或者float,运算的返回值类型与参与运算的值类型相同                           |
| --                               | 自减（前缀后后缀）       |                                                                               |
| =                                | 赋值                     | int、float或bool                                                              |
| += -= *= /=                      | 算术赋值                 | int或float                                                                    |
| < > <= >=                        | 比较                     |                                                                               |
| == !=                            | 比较（是否相等）         | int、float或bool                                                              |
| !                                | 取反                     | bool或结果为bool类型的表达式                                                  |
| &&                               | 逻辑与                   |                                                                               |
| \|\|                             | 逻辑或                   |                                                                               |
| ^^                               | 逻辑异或                 |                                                                               |
| condition?expression:expression2 | 三元选择                 | condition的类型为bool，expression1和expression2的类型可以是除数组外的任意类型 |

## 矢量和矩阵
GLSL ES支持矢量和矩阵类型，矢量和矩阵类型的变量都包含多个元素，每个元素都是一个数值（int,float或bool）。矢量将这些元素排列成一列，可以用来表示顶点坐标或者颜色值等，而矩阵则将元素划分成列和行，可以用来表示变换矩阵。

矢量：(1,2,3)

矩阵：
$$
\left[
 \begin{matrix}
   1 & 4 & 7 \\
   2 & 5 & 8 \\
   3 & 6 & 9 
  \end{matrix} 
\right]
$$

### 矢量和矩阵类型
| 类型 | GLSL_ES数据类型     | 描述                                                    |
| ---- | ------------------- | ------------------------------------------------------- |
| 矢量 | vec2、vec3、vec4    | 具有2、3、4个浮点数元素的矢量                           |
|      | ivec2、ivec3、ivec4 | 具有2、3、4个整型数元素的矢量                           |
|      | bvec2、bvec3、bvec4 | 具有2、3、4个布尔值元素的矢量                           |
| 矩阵 | mat2、mat3、mat4    | 具有2、3、4个浮点数元素的矩阵（分别具有4，9，16个元素） |

### 赋值和构造
我们使用等号（=）来对于矢量和矩阵进行赋值操作。赋值运算符左右两边的变量/值的类型必须一致，左右两边的（矢量或者矩阵）元素个数必须相同。使用构造函数创建指定类型的变量，构造函数的名称和其创建的变量的类型名称总是一致的。

### 矢量构造函数
使用构造函数创建矢量时，只向构造函数传入一个参数时，构造函数就会自动地将这个参数复制给新建矢量的所有元素。但是如果构造函数接受了不止1个参数，但是参数的个数又比矢量的元素个数少，那么就会出错。
```
vec3 v3 = vec3(1.0, 0.0, 0.5); //将v3设为(1.0,0.0,0.5)
vec2 v2 = vec2(v3);            //使用v3的前两个元素，将v2设为(1.0,0.0)
vec4 v4 = vec4(1.0);           //将v4设置为(1.0,1.0,1.0,1.0)
```

将多个矢量组合成一个矢量，先把第一个参数的矢量的所有元素填充进来，如果还没有填满，就继续使用第二个参数的矢量的元素填充。
```
vec4 v4b = vec(v2,v4);         //将v4设为(1.0,0.0,1.0,1.0)
```

### 矩阵构造函数
储存在矩阵中的元素是按照列主序排列的。
- 向矩阵构造函数中传入矩阵的每一个元素的数值来构造矩阵，传入值的顺序必须是列主序的。
  ```
  mat4 m4 = mat4( 1.0, 2.0, 3.0, 4.0,
                  5.0, 6.0, 7.0, 8.0,
                  9.0,10.0,11.0,12.0,
                  13.0,14.0,15.0,16.0);
  ```
$$
\left[
    \begin{matrix}
    1.0 & 5.0 & 9.0 & 13.0 \\
    2.0 & 6.0 & 10.0 & 14.0 \\
    3.0 & 7.0 & 11.0 & 15.0 \\
    4.0 & 8.0 & 12.0 & 16.0 
    \end{matrix}
\right]
$$

-向矩阵构造函数中传入一个或多个矢量，按照列主序使用矢量里的元素来构造矩阵。
```
vec2 v2_1 = vec2(1.0,3.0);
vec2 v2_2 = vec2(2.0,4.0);
mat2 m2_1 = mat2(v2_1,v2_2);

vec4 v4 = vec4(1.0,3.0,2.0,4.0);
mat2 m2_2 = mat2(v4);
```

-向矩阵构造函数中传入矢量和数值，按照列主序使用矢量里面的元素值直接传入的数值来构造矩阵。
```
//使用两个浮点数和一个vec2对象来创建mat2对象
mat2 m2 = mat2(1.0,3.0,v2_2);
```
-向构造函数中传入单个数值，这样将生成一个对角线上元素都是该数值，其他元素为0.0的矩阵。
```
mat4 m4 = mat4(1.0);//1.0 0.0 0.0 0.0
                    //0.0 1.0 0.0 0.0
                    //0.0 0.0 1.0 0.0
                    //0.0 0.0 0.0 1.0
```
- 与矢量构造函数类似，如果传入的数值的数量大于1，又没有达到矩阵元素的数量，就会出错。

### 访问元素
为了访问矢量或者矩阵中的元素，可以使用.或者[]运算符。

### 运算符
在矢量变量名后接点运算符（.），然后接上分量名，就可以访问矢量的元素了。

| ---- | ---- |
| 类别 | 描述 |
| x、y、z、w | 用来获取顶点坐标分量 |
| r、g、b、a | 用来获取颜色分量 |
| s、t、p、q | 用来获取纹理坐标分量 |
由于矢量可以用来存储顶点的坐标、颜色和纹理坐标，所以GLSL ES支持以上三种分量名称以增强程序的可读性。事实上，任何矢量的x、r或s分量都会返回第1个分量。y、g、t分量都会返回第2个分量。
```
vec3 v3 = vec3(1.0,2.0,3.0);
float f;
f = v3.x;//1.0
f = v3.y;//2.0
f = v3.z;//3.0

f = v3.r;//1.0
f = v3.s;//1.0
```

如果试图访问超过矢量长度的分量，就会出错。
```
f = v3.w;
```
将（同一个集合的）多个分量名共同置于点运算符后，就可以从矢量中同时抽取出多个分量。这个过程称作混合。
```
vec2 v2;
v2 = v3.xy;//(1.0,2.0);
v2 = v3.yz;//(2.0,3.0);
v2 = v3.xz;//(1.0,3.0); 可以跳过任意分量
v2 = v3.yx;//(1.0,2.0); 可以逆序
v2 = v3.xx;//(1.0,1.0); 可以重复任意分量
```
聚合分量名也可以用来作为赋值表达式（=）的左值【多个分量名必须属于同一个集合】：
```
vec4 position = vec4(1.0,2.0,3.0,4.0);
position.xw = vec2(5.0,6.0);//position = (5.0,2.0,3.0,6.0);
```

### []运算符
除了.运算符，还可以使用[]运算符并通过数组下标来访问矢量或矩阵的元素。
```
mat4 m4 = mat4(1.0, 2.0, 3.0,4.0,
                5.0, 6.0, 7.0, 8.0,
                9.0, 10.0, 11.0, 12.0
                13.0, 14.0, 15.0, 16.0);
vec4 v4 = m4[0]; //[1.0,2.0,3.0,4.0]
```
连续使用两个[]运算符可以访问某列的某个元素：
```
float m23 = m4[1][2];//(7.0);
```

使用[]运算符和分量名来访问矩阵中的元素：
```
float m32 = m4[2].y;//(10.0);
```
在[]运算符中只能出现索引值必须是常量索引值，常量索引值定义如下：
- 整型字面量
- 用const修饰的全局变量或局部变量，不包括函数参数
- 循环索引
- 由前述三条中的项组成的表达式
```
const int index = 0;
vec4 v4a = m4[index];
vec4 v4b = m4[index + 1];

int index2 = 0;
vec4 v4c = m4[index2];//错误
```
### 运算符
矢量和矩阵可用的运算符
| 运算符         | 运算             | 适用数据类型                             |
| -------------- | ---------------- | ---------------------------------------- |
| *              | 乘法             | 适用于vec[234]和mat[234]                 |
| /              | 除法             | 适用于vec[234]和mat[234]                 |
| +              | 加法             | 运算结果的数据类型与参与运算的类型相一致 |
| -              | 减法             |                                          |
| ++             | 自增(前缀或后缀) | 适用于vec[234]和mat[234]                 |
| --             | 自减(前缀或后缀) |                                          |
| =              | 赋值             | 适用于vec[234]和mat[234]                 |
| +=、-=、*=、/= | 运算赋值         | 适用于vec[234]和mat[234]                 |
| ==、!=         | 比较             | 适用于vec[234]和mat[234]                 |
当运算赋值操作作用于矢量或矩阵时，实际上时逐分量地对矩阵或矢量的每一个元素进行独立的运算赋值。

### 矢量和浮点数的运算
```
vec3 v3a,v3b,v3c;
mat3 m3a,m3b,m3c;
float f;

v3b = v3a + f;//v3b.x = v3a.x + f;v3b.y = v3a.y + f;v3b.z = v3a.z + f;
```

### 矢量运算
矢量的运算操作发生在矢量的每个分量上。
```
v3c = v3a + v3b;//v3a.x + v3b.x;v3a.y+v3b.y;v3a.c+v3b.c;
```

### 矩阵和浮点数的运算
矩阵与浮点数的运算发生在矩阵的每个分量上。
```
m3b = m3a * f;//m3b[0].x = m3a[0].x * f;m3b[0].y = m3a[0].z * f;
              //m3b[1].x = m3a[1].x * f;m3b[1].y = m3a[1].z * f;
              //m3b[2].x = m3a[2].x * f;m3b[2].y = m3a[2].z * f;
```
### 矩阵右乘矢量
矩阵右乘矢量的结果是矢量，其中每个分量都是原矢量中的对应分量，乘上矩阵对应行的每个元素的积的加和。
```
v3b = m3a * v3a;
//v3b.x = m3a[0].x * v3a.x + m3a[1].x * v3a.y + m3a[2].x * v3a.z;
//v3b.y = m3a[0].y * v3a.x + m3a[1].y * v3a.y + m3a[2].y * v3a.z;
//v3b.z = m3a[0].z * v3a.x + m3a[1].z * v3a.y + m3a[2].z * v3a.z;
```

### 矩阵左乘矢量
```
v3b = v3a * m3a;
//v3b.x = v3a.x *m3a[0].x + v3b.y * m3a[0].y + v3a.z * m3a[0].z;
//v3b.y = v3a.x *m3a[1].x + v3b.y * m3a[1].y + v3b.z * m3a[1].z;
//v3c.z = v3a.x *m3a[2].x + v3b.z * m3a[2].y + v3b.z * m3a[2].z;
```

### 矩阵与矩阵相乘
```
m3c = m3a * m3b;
//m3c[0].x = m3a[0].x * m3b[0].x + m3a[1].x * m3b[0].y + m3a[2].x * m3b[0].z;
//m3c[1].x = m3a[0].x * m3b[1].x + m3a[1].x * m3b[1].y + m3a[2].x * m3b[1].z;
//m3c[2].x = m3a[0].x * m3b[2].x + m3a[1].x * m3b[2].y + m3a[2].x * m3b[2].z;
//m3c[0].y = m3a[0].y * m3b[0].x + m3a[1].y * m3b[0].y + m3a[2].y * m3b[0].z;
//m3c[1].y = m3a[0].y * m3b[1].x + m3a[1].y * m3b[1].y + m3a[2].y * m3b[1].z;
//m3c[2].y = m3a[0].y * m3b[2].x + m3a[1].y * m3b[2].y + m3a[2].y * m3b[2].z;
//m3c[0].z = m3a[0].z * m3b[0].x + m3a[1].z * m3b[0].y + m3a[2].z * m3b[0].z;
//m3c[1].z = m3a[0].z * m3b[1].x + m3a[1].z * m3b[1].y + m3a[2].z * m3b[1].z;
//m3c[2].z = m3a[0].z * m3b[2].x + m3a[1].z * m3b[2].y + m3a[2].z * m3b[2].z;
```

## 结构体
GLSL ES支持用户自定义的类型，即结构体。使用关键词struct，将已存在的类型聚合到一起，就可以定义为结构体。
```
struct light{//定义结构体类型light
    vec4 color;
    vec3 position;
}

light l1,l2;//声明ligth类型的l1和l2
```
为了方便，可以在同一条语句中定义结构体并声明该结构体类型的变量。
```
struct light{
    vec4 color;
    vec3 position;
}l1;
```

### 赋值和构造
结构体有标准的构造函数，其名称和结构体名一致。构造函数的参数顺序必须与结构体定义中的成员顺序一致。
```
l1 = light(vec4(0.0,1.0,0.0,1.0),vec3(8.0,3.0,0.0));
```

### 访问成员
在结构体变量名后跟点运算符（.），然后再加上成员名，就可以访问变量的成员。
```
vec4 color = l1.color;
vec3 position = l1.position;
```

### 运算符 
结构体的成员可以参与其自身类型支持的任何运算，但结构体本身只支持两种运算：赋值（=）和比较（==和!=）。
| 运算符 | 运算 | 描述 |
| ----- | ----- | ----- |
| = | 赋值 | 赋值和比较运算符不适用于含有数组与纹理成员的结构体 |
| ==、!= | 比较 |  |

## 数组
GLSL ES支持数组类型。GLSL ES只支持一维数组。声明数组只需要在变量名后加上中括号（[]）和数组的长度。
```
float floatArray[4];
vec4 vec4Array[2];
```
数组的长度必须大于0的整数常量表达式：
- 整型字面量
- 用const限定字修饰的全局变量或局部变量，不包括函数参数。
- 用前述两条中的项组成的表达式

数组不能再声明时被一次性地初始化，必须显示地对每个元素进行初始化。

## 取样器（纹理）


